"use strict"; 
/*Типы данных в JS
Простые типы данных:
1. Числа:
let number = 4.6;
console.log(-4 / 0); - -infinity - -бесконечноть
console.log('string' * 9); - NaN - not a number
2. Сторка - string
const person = 'Alex';
const person = '5';
3. Null
console.log(something);
4. Undefined
let und;
console.log(und);
5. Symbol, 6.BigInt - редко используются в практике
7. Логический тип данных boolean значения - true/false


Объекты - структура, которая используется для хранения любых данных
Для обозначения объкта используются {}. Объект содержит в себе свойтства и действия (методы)
const obj = {
    name: 'John',
     age: 25,
     isMarried: false
 };
console.log(obj.name);
console.log(obj ['name']);

let arr = ['plump.png', 'orange.jpg', 6, 'apple.bmp', [] , {}];
console.log(arr[1]);

Простое общение с пользователем
alert('Hello');

const result = confirm('Are you her?');
console.log(result);

const answer = +prompt('Вам есть 18,?','18');
console.log(answer +5);

const answers = [];

answers[0] = prompt('Как ваше имя?', '');
answers[1] = prompt('Как ваше фамилия?', '');
answers[2] = prompt('Сколько вам лет?', '');


console.log(typeof(answers));


Интерполяция - это значит что внутри строки мы можем вставлять значение переменной
 
const category = 'toys';

console.log(`https://someurl.com/${category}/5`);

const user = 'Ivan';
console.log(`Привет, ${user}`);


Опператоры в JS

console.log('arr' + ' - object');
console.log(4 + +' - object');
console.log(4 + +'5');

Инкримент, декремент

let incr = 10,
     decr = 10;
++incr;
--decr;
console.log(++incr);
console.log(--decr);

console.log(5 % 2); Оператор % - возвращает число, которое осталось после того как 5/2 максимальное количество раз

console.log(2 +2* 2 !== '6'); оператор != не равно 
 = - присваивание; == сравнение по значению; === - строгое сравнение, и по значению, и по типу данных (строка===строка)


 const isChecked = false,
isClose = false;
console.log(isChecked || !isClose);

Условия - превращают любой тип данніх в будиновое значение false\true 
Мы можем взять содержимое какого-то элемента и поместить в if,
если содержимое будет пристутсвовать то выполниться первая часть if
если же нет, то выполниться else

if (4 == 9) {
    console.log('ok');
} else {
    console.log('Erorr');
}

if (1) {
    console.log('ok');
} else {
    console.log('Erorr');
}
*/
/* Чаще всего условий у нас много и мы можем их проверять при помощи вложенности:
const num = 50;

if (num < 49) {
     console.log('Erorr');
} else if (num > 100) {
     console.log('Много');
} else {
     console.log('Ok!');
} 
*/
/*Другой синтаксис условий с помощью тернарного оператора (в эго работе использунтся аж 3 аргумента):
сначала идет условие, которое хотим проверить (num ===50), далее ?,
далее если условие верно, то мы вополняем вот это действие:console.log('Ok!'),
если условие не выполнено, то мы выполняем вот это действие: console.log('Erorr'); 
Также есть бинарные аргументы  4+4 (+ будет бинарным аргументом)
Также есть унарные аргументы  +'4'; (+ будет унарным аргументом, который будер работать с одной 4) 
 
(num === 50) ?  console.log('Ok!') : console.log('Erorr'); */

/*Для того чтобы избежать больших конструкций if/else используется специальная
конструкия СВИТЧ - это такая можификация которая поддерживает несколько условий и проверок 
Конструкция СВИТЧ поддерживает только строгое сравнение, в отличие от классической конструкции
Case может быть сколько угодно, и может не выполняться ни один case,
плэтому в конце прописывается default: (условия по дефолту)

const num = '50';

switch (num) {
    case '49':
        console.log('Неверно');
        break;
    case '100':
        console.log('Неверно');
        break;
    case '50':
        console.log('В точку!');
        break;
    default:
         console.log('Не в этот раз!');
        break;
}*/



/* ЦИКЛЫ - используются для повторения однотипных действий
В JS существует 3 способа реализации и применениние того или иного способа зависит от ситуации

 1 - While - пока это условие не будет выполнено, мы будем делать эти действия

let num = 50;

while (num <= 55) {
    console.log(num);
    num++;
} */

/* 2-способ, мы сначала заставляем наш цикл, что-то сделать, 
а потом уже проверить условие, и если необходимо выйти из цикла

let num = 50;
do {
    console.log(num);
    num++;
}
while (num < 55); */

/* 3 способ самый часто использующийся это - цикл for.
Он такой популярный потому что его можно весьма подробно его настроить 
Сначала идет ключевое слово for, далее окрываются скобки 
() - это условие, которое состоит из 3-х аргументов, но они на самом деле не обязательны
Далее в скобках на первом месте стоит let i (итераторр) = 1;
; - ставится между аргументами наших условий 
На втором месте стоит условие, при выполнении которого наш цикл остановит работу,
например i<8;
На третьем месте мы записываем шаг цикла, то есть что будет происходить каждый раз в новом цикле 
Чаще вснго на практике используется конструкция с инкриментом,
например i++
Итого, переменная i в каждой итеррации (повторение цикла) будет увеличиваться на 1:
Если в условии поставить i<0, то мы запустим бесконечный цикл


let num = 50;
for (let i = 1; i < 8; i++) {
     console.log(num);
     num++;
}*/
/* Иногда цикл нужно закончить досрочно, если переменная приняла какое-то специфическое значение 
сделать это можно при помощи команды break

Оператор continue - позволяет пропустить тот шаг, который нам не нужен, 
но при этом не прерывает нам полностью цикл. На практике это очень удобно,
если мы хотим избежать включения каких-то отчетных значений или опеределенных значений в переборе нашего цикла


let num = 50;
for (let i = 1; i < 10; i++) {
    if (i === 6) {
        //break
        continue;
    }
    console.log(i);
}*/



/* ФУНКЦИИ  - это наши действия в JS, они используют разные типы данных
и изменяют информацию так, как мы ей укажем 
function название (аргументы) {
    какие-то действия 
}
После того как мы обьявили функцию, нам нужно ее вызвать:
название функции ();

Аргументов может быть множество, они ставяться через запятую:
function showFirstMessege(text, arg, num и т.д)


Когда функция вызывается мы можем дать ей каки-то данные, которые она будет использовать 
внутри себя.
Соответственно, когда функция запуститься, она возьмет эту строку, 
которую мы ей передали, например showFirstMessege('Hello world!');,
Hello world! - подставиться вместо аргумента, например (text),
и потом засунет эти данные в команду, которая есть в функции, напимер  console.log(text);



Существует негласное правило, что название функции должно быть глаголом 
с припиской того над чем выполняется действие.
Иногда можно встретить анонимные функции без имени, они используются здесь и сейчас,
только один раз.

function showFirstMessege(text) {
    console.log(text);
}
showFirstMessege('Hello world!');
*/
/* Как ведут себя переменные внутри этой функции: если обьявляем переменную
внутри функции (локальная переменная), то снаружи она уже не доступна.
Переменные созданные с помощью let и const существуют внутри блока функции {}.
Можно использовать глобальные переменные внутри функции 




let num = 20; // глобальная переменная
function showFirstMessege(text) {
    console.log(text);
    num = 10;
}
showFirstMessege('Hello world!');
console.log(num); // получим 10



let num = 20; // глобальная переменная
function showFirstMessege(text) {
    console.log(text);
    let num = 10;
}
showFirstMessege('Hello world!');
console.log(num); // получим 20, потому что в данном случпе мы обращаемся к глобальной переменной, а let num = 10 внутри функции не видна 
*/

/* ЗАМЫКАНИЕ ФУНКЦИИ  - это сама функция со всеми внешними переменными,
которые ей доступны.

Когда у нас внутри функции есть обращение к какой-либо переменной, то сначала 
функция ищет эту переменную внутри себя, если находит, то выводит ее, если не находит,
то функция ищет эту переменную на порядлок выше, и выводит уже глобальную функцию



let num = 20; // глобальная переменная
function showFirstMessege(text) {
    console.log(text);
    let num = 10; // локальная переменная 
    console.log(num); // >> выведет 10
}
showFirstMessege('Hello world!'); // >> выведет Hello world
console.log(num);  // >> выведет 20



let num = 20; // глобальная переменная
function showFirstMessege(text) {
    console.log(text);
    console.log(num); // >> выведет 20
}
showFirstMessege('Hello world!'); // >> выведет Hello world
console.log(num);  // >> выведет 20
*/

/* Кроме этого функция может вернуть нам какое-либо значение при помощи 
ключевого слова return во внешний мир. Как только функция увидит слово return она остановит свое действие 

function calc (a, b) {
    return (a + b);
    console.log('cdcd'); // unreacheble -недостижимый,тк он после слова return.Этот код мертвый, он никогда не выполнится
}
console.log(calc(4, 3));
console.log(calc(5, 6));
console.log(calc(10, 6));
*/

/* Кроме этого return возвращает нам во внешний мир переменную,
 которая внутри функции  
function ret() {
    let num = 50;

    /// тут может быть еще куча диугого кода 

    return num;
}

const anotherNum = ret(); // переменная, в которую мы поместили результат работы функции ret
console.log(anotherNum);
*/


/*КЛАССИФИКАЦИЯ ФУНКЦИЙ (3 вида): 
1. function declaration
function foo (){
    код
}
Создается до начала выполнения скрипта, можно вызвать перед обьявлением.
Это то что мы уже разобрали выше. 

2. function expresion
let foo = function (){
    код
};
Создается только тогда, когда доходит поток кода, 
можно вызвать только после обьявления 


const logger = function () {
    console.log('Hello');
};
logger();

3. Стрелочная функция 
()=>
Не имеет свого контекста вызова (this)
Ек чаще всегоможно встретить в обрабработке событий 


const calc = (a, b) => { return a + b };
Второй вариант записи, при больщом коде:
const calc = (a, b) => {
    console.log('1');
    return a + b;
};
*/

/* МЕТОДЫ И СВОЙСТВА У СТРОК И ЧИСЕЛ 
Методы - это вспомогательные функции. Вызываются через точку и () в концк. 
Выполняют какое-то действие над строкой.
Свойства - вспомогательны значения. Вызваются через точку 

console.dir (); - выводит какой-то элемент в виде объекта 

Свойства строк 
const str = 'test';
const arr = [1, 2, 3];

console.log(str.length); // получим длинну str
console.log(str[2]); // получим третью букву в строке

Методы изменения регистра строк:

console.log(str.toUpperCase());//вернет большими буквами TEST
console.log(str.toLowerCase()); // вернет маленькими буквами test 

console.log(str); // вернет маленькими буквами test
*/
/*Метод, который позволяет вам найти кусочек вашей строки и сказать с какого индекса
//(какой позиции) она начинается - поиск подстроки. Иногда этот метод используется для того , 
чтобы определить есть ли в этой строке искомое значение  

const fruit = 'Some fruit';

console.log(fruit.indexOf('fruit')); // получим 5, потому что fruit начинается с 5 индекса 
console.log(fruit.indexOf('q')); // получим -1, это означает, что такая буква, такой кусочек строки не был найден
 */
/*Методы, которые могут изменять и модифицировать строку, в JS таких 3 штуки */
// первый метод slice
//const logg = 'Hello world';

//console.log(logg.slice(6, 11)); // получим world/ первый аргумент говорит нам с какой части строки нам возвращать что-то,
//втрой аргумент говорит нам где заканчивать вырезание кусочка, и указываем то, что не включается


/*const ann = 'Ann loves Alex';
console.log(ann.slice(10, 14));*/ // получим Alex

// второй способ использования slice, это написать только первый аргумент, то есть индекс с какого начинается строка, которую мы хотим вызвать
//console.log(logg.slice(6)); // получим world

// метод slice поддерживает и отрицательные значения, то есть аргументы начинаются с конца строки
// console.log(logg.slice(-5, -1)); // получим worl


/*второй метод substring
const logg = 'Hello world';
console.log(logg.substring(6, 11)); // аргументы это start и end, похож на slice, но не поддерживает отрицательные значения 
*/
/*третий метод substr - говорит сколько символов нужно вырезать 
const logg = 'Hello world';
console.log(logg.substr(6,5)); // первый аргумент - это начало, откуда нужно вырезать, второй аргумент - это длинна, то есть сколько символов нам нужно вырезать
*/

/* МЕТОДЫ И СВОЙСТВА ЧИСЕЛ
В JS есть отдельная мини-библиотека, которую можно выхвать в консоле браузера Math.

Округление 
const num = 12.2;
console.log(Math.round(num));

Метод parseInt переводит число в другую систему исчисления
const test = '12.2px';
console.log(parseInt(test)); // получим число 12 

Метод parseFloat переводит число или строку в дестичную систему 
console.log(parseFloat(test)); // получим число 12.2
*/



























let numberOfFilms;

function start() {
    numberOfFilms = +prompt('Сколько фильмов Вы уже посмотрели?', '');

    while (numberOfFilms == '' || numberOfFilms==null || isNaN(numberOfFilms)) {
         numberOfFilms = +prompt('Сколько фильмов Вы уже посмотрели?', '');
    }
}
start();

const personalMovieDB = {
    count: numberOfFilms,
    movies: {},
    actors: {},
    genres: [],
    privat: false
};

/* Первый способ обьявить цикл
let j = 0;
while (j < 2) {
    const a = prompt('Один из последних просмотренных фильмов?', ''),
        b = prompt('На сколько оцените его?', '');
    
    if (a != null && b != null && a != '' && b != '' && a.length < 50 && b.length < 50) {
        personalMovieDB.movies[a] = b;
        console.log('done');
        j++;
    } else {
        console.log('erorr');
        
    }
}*/

/* Второй способ обьявить цикл 
let j = 0;
do {
    const a = prompt('Один из последних просмотренных фильмов?', ''),
        b = prompt('На сколько оцените его?', '');
    
    if (a != null && b != null && a != '' && b != '' && a.length < 50 && b.length < 50) {
        personalMovieDB.movies[a] = b;
        console.log('done');
        j++;
    } else {
        console.log('erorr');
    }

} while (j < 2);*/


// Третий способ обьявить цикл (самый частый)

 
function rememberMyFilms() {
     for (let i = 0; i < 2; i++) {
    const a = prompt('Один из последних просмотренных фильмов?', ''),
          b = prompt('На сколько оцените его?', '');
    
     if (a != null && b != null && a != '' && b != '' && a.length < 50 && b.length < 50) {
         personalMovieDB.movies[a] = b;
         console.log('done');
     } else {
         console.log('erorr');
         i--;
     }
    }
}
// rememberMyFilms();



function detectedPersonalLevel() {
    if (personalMovieDB.count < 10) {
        console.log('Просмотрено довольно мало фильмов');
    } else if (personalMovieDB.count >= 10 && personalMovieDB.count < 30) {
        console.log('Вы классический зритель');
    } else if (personalMovieDB.count >= 30) {
        console.log('Вы киноман');
    } else {
        console.log('Произошла ошибка');
    }
}

// detectedPersonalLevel();

function showMyDB(hidden) {
    if (!hidden) {
        console.log(personalMovieDB);
    }
}
// showMyDB(personalMovieDB.privat);


function writeYourGenres() {
    
    for (let i = 1; i <= 3; i++) {
         const genre = prompt(`Ваш любимы жанр под номером ${i}`);

        if (genre != null && genre != '') {
            personalMovieDB.genres[i - 1] = genre;
        }
    }  
    console.log(personalMovieDB);
}
writeYourGenres();