"use strict"; 
// Типы данных в JS  
// Простые типы данных:
// 1. Числа:
// let number = 4.6;
// console.log(-4 / 0); - -infinity - -бесконечноть
// console.log('string' * 9); - NaN - not a number
// 2. Сторка - string
// const person = 'Alex';
// const person = '5';
// 3. Null
// console.log(something);
// 4. Undefined
// let und;
// console.log(und);
// 5. Symbol, 6.BigInt - редко используются в практике
// 7. Логический тип данных boolean значения - true/false


// Объекты - структура, которая используется для хранения любых данных
// Для обозначения объкта используются {}. Объект содержит в себе свойтства и действия (методы)
// const obj = {
//     name: 'John',
//      age: 25,
//      isMarried: false
//  };
// console.log(obj.name); обращение к конкретному свойству объекта через точку
// console.log(obj ['name']); обращение к конкретному свойству объекта через []

// let arr = ['plump.png', 'orange.jpg', 6, 'apple.bmp', [] , {}];
// console.log(arr[1]);

// Простое общение с пользователем
// alert('Hello');

// const result = confirm('Are you her?');
// console.log(result);

// const answer = +prompt('Вам есть 18,?','18');
// console.log(answer +5);

// const answers = [];

// answers[0] = prompt('Как ваше имя?', '');
// answers[1] = prompt('Как ваше фамилия?', '');
// answers[2] = prompt('Сколько вам лет?', '');


// console.log(typeof(answers));


// Интерполяция - это значит что внутри строки мы можем вставлять значение переменной
 
// const category = 'toys';

// console.log(`https://someurl.com/${category}/5`);

// const user = 'Ivan';
// console.log(`Привет, ${user}`);


// Опператоры в JS

// console.log('arr' + ' - object');
// console.log(4 + +' - object');
// console.log(4 + +'5');

// Инкримент, декремент

// let incr = 10,
//      decr = 10;
// ++incr;
// --decr;
// console.log(++incr);
// console.log(--decr);

// console.log(5 % 2); Оператор % - возвращает число, которое осталось после того как 5/2 максимальное количество раз

// console.log(2 +2* 2 !== '6'); оператор != не равно
//  = - присваивание; == сравнение по значению; === - строгое сравнение, и по значению, и по типу данных (строка===строка)


//  const isChecked = false,
// isClose = false;
// console.log(isChecked || !isClose);

// Условия - превращают любой тип данніх в будиновое значение false\true
// Мы можем взять содержимое какого-то элемента и поместить в if,
// если содержимое будет пристутсвовать то выполниться первая часть if
// если же нет, то выполниться else

// if (4 == 9) {
//     console.log('ok');
// } else {
//     console.log('Erorr');
// }

// if (1) {
//     console.log('ok');
// } else {
//     console.log('Erorr');
// }
// */
/* Чаще всего условий у нас много и мы можем их проверять при помощи вложенности:
const num = 50;

if (num < 49) {
     console.log('Erorr');
} else if (num > 100) {
     console.log('Много');
} else {
     console.log('Ok!');
} 
*/
/*Другой синтаксис условий с помощью тернарного оператора (в эго работе использунтся аж 3 аргумента):
сначала идет условие, которое хотим проверить (num ===50), далее ?,
далее если условие верно, то мы вополняем вот это действие:console.log('Ok!'),
если условие не выполнено, то мы выполняем вот это действие: console.log('Erorr'); 
Также есть бинарные аргументы  4+4 (+ будет бинарным аргументом)
Также есть унарные аргументы  +'4'; (+ будет унарным аргументом, который будер работать с одной 4) 
 
(num === 50) ?  console.log('Ok!') : console.log('Erorr'); */

/*Для того чтобы избежать больших конструкций if/else используется специальная
конструкия СВИТЧ - это такая можификация которая поддерживает несколько условий и проверок 
Конструкция СВИТЧ поддерживает только строгое сравнение, в отличие от классической конструкции
Case может быть сколько угодно, и может не выполняться ни один case,
плэтому в конце прописывается default: (условия по дефолту)

const num = '50';

switch (num) {
    case '49':
        console.log('Неверно');
        break;
    case '100':
        console.log('Неверно');
        break;
    case '50':
        console.log('В точку!');
        break;
    default:
         console.log('Не в этот раз!');
        break;
}*/



/* ЦИКЛЫ - используются для повторения однотипных действий
В JS существует 3 способа реализации и применениние того или иного способа зависит от ситуации

 1 - While - пока это условие не будет выполнено, мы будем делать эти действия

let num = 50;

while (num <= 55) {
    console.log(num);
    num++;
} */

/* 2-способ, мы сначала заставляем наш цикл, что-то сделать, 
а потом уже проверить условие, и если необходимо выйти из цикла

let num = 50;
do {
    console.log(num);
    num++;
}
while (num < 55); */

/* 3 способ самый часто использующийся это - цикл for.
Он такой популярный потому что его можно весьма подробно его настроить 
Сначала идет ключевое слово for, далее окрываются скобки 
() - это условие, которое состоит из 3-х аргументов, но они на самом деле не обязательны
Далее в скобках на первом месте стоит let i (итераторр) = 1;
; - ставится между аргументами наших условий 
На втором месте стоит условие, при выполнении которого наш цикл остановит работу,
например i<8;
На третьем месте мы записываем шаг цикла, то есть что будет происходить каждый раз в новом цикле 
Чаще вснго на практике используется конструкция с инкриментом,
например i++
Итого, переменная i в каждой итеррации (повторение цикла) будет увеличиваться на 1:
Если в условии поставить i<0, то мы запустим бесконечный цикл


let num = 50;
for (let i = 1; i < 8; i++) {
     console.log(num);
     num++;
}*/
/* Иногда цикл нужно закончить досрочно, если переменная приняла какое-то специфическое значение 
сделать это можно при помощи команды break

Оператор continue - позволяет пропустить тот шаг, который нам не нужен, 
но при этом не прерывает нам полностью цикл. На практике это очень удобно,
если мы хотим избежать включения каких-то отчетных значений или опеределенных значений в переборе нашего цикла


let num = 50;
for (let i = 1; i < 10; i++) {
    if (i === 6) {
        //break
        continue;
    }
    console.log(i);
}*/



/* ФУНКЦИИ  - это наши действия в JS, они используют разные типы данных
и изменяют информацию так, как мы ей укажем 
function название (аргументы) {
    какие-то действия 
}
После того как мы обьявили функцию, нам нужно ее вызвать:
название функции ();

Аргументов может быть множество, они ставяться через запятую:
function showFirstMessege(text, arg, num и т.д)


Когда функция вызывается мы можем дать ей каки-то данные, которые она будет использовать 
внутри себя.
Соответственно, когда функция запуститься, она возьмет эту строку, 
которую мы ей передали, например showFirstMessege('Hello world!');,
Hello world! - подставиться вместо аргумента, например (text),
и потом засунет эти данные в команду, которая есть в функции, напимер  console.log(text);



Существует негласное правило, что название функции должно быть глаголом 
с припиской того над чем выполняется действие.
Иногда можно встретить анонимные функции без имени, они используются здесь и сейчас,
только один раз.

function showFirstMessege(text) {
    console.log(text);
}
showFirstMessege('Hello world!');
*/
/* Как ведут себя переменные внутри этой функции: если обьявляем переменную
внутри функции (локальная переменная), то снаружи она уже не доступна.
Переменные созданные с помощью let и const существуют внутри блока функции {}.
Можно использовать глобальные переменные внутри функции 




let num = 20; // глобальная переменная
function showFirstMessege(text) {
    console.log(text);
    num = 10;
}
showFirstMessege('Hello world!');
console.log(num); // получим 10



let num = 20; // глобальная переменная
function showFirstMessege(text) {
    console.log(text);
    let num = 10;
}
showFirstMessege('Hello world!');
console.log(num); // получим 20, потому что в данном случпе мы обращаемся к глобальной переменной, а let num = 10 внутри функции не видна 
*/

// ЗАМЫКАНИЕ ФУНКЦИИ  - это сама функция со всеми внешними переменными,
// которые ей доступны.

// Когда у нас внутри функции есть обращение к какой-либо переменной, то сначала
// функция ищет эту переменную внутри себя, если находит, то выводит ее, если не находит,
// то функция ищет эту переменную на порядлок выше, и выводит уже глобальную функцию



// let num = 20; // глобальная переменная
// function showFirstMessege(text) {
//     console.log(text);
//     let num = 10; // локальная переменная
//     console.log(num); // >> выведет 10
// }
// showFirstMessege('Hello world!'); // >> выведет Hello world
// console.log(num);  // >> выведет 20



// let num = 20; // глобальная переменная
// function showFirstMessege(text) {
//     console.log(text);
//     console.log(num); // >> выведет 20
// }
// showFirstMessege('Hello world!'); // >> выведет Hello world
// console.log(num);  // >> выведет 20



// Кроме этого функция может вернуть нам какое-либо значение при помощи
// ключевого слова return во внешний мир. Как только функция увидит слово return она остановит свое действие

// function calc (a, b) {
//     return (a + b);
//     console.log('cdcd'); // unreacheble -недостижимый,тк он после слова return.Этот код мертвый, он никогда не выполнится
// }
// console.log(calc(4, 3));
// console.log(calc(5, 6));
// console.log(calc(10, 6));



// Кроме этого return возвращает нам во внешний мир переменную,
//  которая внутри функции
// function ret() {
//     let num = 50;

//     /// тут может быть еще куча диугого кода

//     return num;
// }

// const anotherNum = ret(); // переменная, в которую мы поместили результат работы функции ret
// console.log(anotherNum);



// КЛАССИФИКАЦИЯ ФУНКЦИЙ (3 вида):
// 1. function declaration
// function foo (){
//     код
// }
// Создается до начала выполнения скрипта, можно вызвать перед обьявлением.
// Это то что мы уже разобрали выше.

// 2. function expresion
// let foo = function (){
//     код
// };
// Создается только тогда, когда доходит поток кода,
// можно вызвать только после обьявления


// const logger = function () {
//     console.log('Hello');
// };
// logger();

// 3. Стрелочная функция
// ()=>
// Не имеет свого контекста вызова (this)
// Ек чаще всегоможно встретить в обрабработке событий


// const calc = (a, b) => { return a + b };
// Второй вариант записи, при больщом коде:
// const calc = (a, b) => {
//     console.log('1');
//     return a + b;
// };


// МЕТОДЫ И СВОЙСТВА У СТРОК И ЧИСЕЛ
// Методы - это вспомогательные функции. Вызываются через точку и () в концк.
// Выполняют какое-то действие над строкой.
// Свойства - вспомогательны значения. Вызваются через точку

// console.dir (); - выводит какой-то элемент в виде объекта

// Свойства строк
// const str = 'test';
// const arr = [1, 2, 3];

// console.log(str.length); // получим длинну str
// console.log(str[2]); // получим третью букву в строке

// Методы изменения регистра строк:

// console.log(str.toUpperCase());//вернет большими буквами TEST
// console.log(str.toLowerCase()); // вернет маленькими буквами test

// console.log(str); // вернет маленькими буквами test


// Метод, который позволяет вам найти кусочек вашей строки и сказать с какого индекса
// //(какой позиции) она начинается - поиск подстроки. Иногда этот метод используется для того ,
// чтобы определить есть ли в этой строке искомое значение

// const fruit = 'Some fruit';

// console.log(fruit.indexOf('fruit')); // получим 5, потому что fruit начинается с 5 индекса
// console.log(fruit.indexOf('q')); // получим -1, это означает, что такая буква, такой кусочек строки не был найден
 

// Методы, которые могут изменять и модифицировать строку, в JS таких 3 штуки
// первый метод slice
//const logg = 'Hello world';

//console.log(logg.slice(6, 11)); // получим world/ первый аргумент говорит нам с какой части строки нам возвращать что-то,
//втрой аргумент говорит нам где заканчивать вырезание кусочка, и указываем то, что не включается


// const ann = 'Ann loves Alex';
// console.log(ann.slice(10, 14)); // получим Alex

// второй способ использования slice, это написать только первый аргумент, то есть индекс с какого начинается строка, которую мы хотим вызвать
//console.log(logg.slice(6)); // получим world

// метод slice поддерживает и отрицательные значения, то есть аргументы начинаются с конца строки
// console.log(logg.slice(-5, -1)); // получим worl


// второй метод substring
// const logg = 'Hello world';
// console.log(logg.substring(6, 11)); // аргументы это start и end, похож на slice, но не поддерживает отрицательные значения

// третий метод substr - говорит сколько символов нужно вырезать
// const logg = 'Hello world';
// console.log(logg.substr(6,5)); // первый аргумент - это начало, откуда нужно вырезать, второй аргумент - это длинна, то есть сколько символов нам нужно вырезать


//  МЕТОДЫ И СВОЙСТВА ЧИСЕЛ
// В JS есть отдельная мини-библиотека, которую можно выхвать в консоле браузера Math.

// Округление
// const num = 12.2;
// console.log(Math.round(num));

// Метод parseInt переводит число в другую систему исчисления
// const test = '12.2px';
// console.log(parseInt(test)); // получим число 12

// Метод parseFloat переводит число или строку в дестичную систему
// console.log(parseFloat(test)); // получим число 12.2


// Callback - ФУНКЦИИ
// Классические функции используются не в совсем очевидных местах и не в совсем очевидных конструкциях



// function first() {
//     // Do something
//     setTimeout(function () {
//         console.log(1);
//     }, 500);
// }

// function second() {
//     console.log(2);
// }

// first();
// second(); // получим сначала 2, потом 1, потому что первая функция записана с задержкой на 500 мс

// //Если функции идут в коде одна за другой, это не значит, что они так и будут работать по порядку
// // CALLBACK- ФУНКЦИЯ - это функция, которая должна быть выполнена после того, как другая функция завершила свое выполнения

// function learnJS(lang, callback) {
//     console.log(`Я учу: ${lang}`);
//     callback();
// }
// // lang - первый аргумент, которому мы просто передаем какую-то строку с языком
// // callback - второй аргумент, в которую мы передаем другую функцию
// function done() {
//     console.log('Я прошел этот урок');
// }

// learnJS('JavaScript', done); // я сказала, функция learnJS, выполни функцию done,
// когда ты до нее дойдешь (callback).
// то есть функция done стоит вторым аргументом и вызывается после того, как функция learnJS до нее дойдет



/*Объекты, деструктуризация объектов (ES6)
Объекты в JS это так называемые ассоциативные массивы.
Объекты могут хранить в себе любые типы данных в формате ключ: значение.
Также объкты могут быть вложены в объекты, массивы в объекты и тд
Чтобы их перебрать мы можем использовать такую конструкцию как for...in (смотри ниже),
и внутри делать все что угодно, как с ключами, так и со значениеми этих ключей.
у объектов бывают встроенные методы и встроенные свойства. 
Ну и также для того чтобы, объект наш умел что-либо делать, мы можем внутри него записывать функции,
и потом вызывать их как метод объекта.

Также есть таконе понятие, как свойства акцессоры - это гет и сет, но об этом позже

*/
// const obj = new Object(); - это второй вариант назвать объект

// const options = {
//     name: 'test', // ключ: значение
//     width: 1024,
//     height: 1024,
//     colors: {
//         border: 'black',
//         bg: 'red'
//     },
//     makeTest: function () {
//         console.log('Test');
//     }
// };
// options.makeTest();
//console.log(options.name);  вызвать какое-то свойсто из объкта можно через точку или чераз []
//console.log(options['colors']['border']);  - получим black.
// Если у нас есть в свойствах объекта какой - то вложеный объект, то чтобы вызвать конкретной свойство вложенного объекта, то нужно использовать такую конструкцию

// delete options.name; // метод delete позволяет удалить какое-то свойство в объекте,в данном случае удалиться свойство name
// console.log(options);

// Чтобы перебрать все свойства объкта мы можем воспользоваться следующей конструкцией:

// for (let key in options) {
//      console.log(`Свойство ${key} имеет значение ${options[key]}`); // мы все значения выводим в качестве строк
// }

// Мы получим:
/*Свойство name имеет значение test
Свойство width имеет значение 1024
Свойство height имеет значение 1024
Свойство colors имеет значение [object Object]
Свойство makeTest имеет значение function () {
        console.log('Test');
    } */



// Если в объекте вложеный объект, то нужно использовать следующую конструкцию, чтобы вывести и свойства вложенного объекта в основной объект
// то есть нам нуджно вывести свойства объекта colors
// for (let key in options) {
//     if (typeof (options[key]) === 'object') {
//             for (let i in options[key]) {
//                 console.log(`Свойство ${i} имеет значение ${options [key] [i]}`);
//             }
//        } else {
//             console.log(`Свойство ${key} имеет значение ${options[key]}`);
//         }
// }
/* Получим:
Свойство name имеет значение test
Свойство width имеет значение 1024
Свойство height имеет значение 1024
Свойство border имеет значение black
Свойство bg имеет значение red
Свойство makeTest имеет значение function () {
        console.log('Test');
    }
*/






/* ФУНКЦИИ И МЕТОДЫ, КОТОРЫЕ ЕСТЬ УЖЕ ВНУТРИ ОБЪЕКТА
Методы - это действия, которые могут выполнять наши объекты */
// ПРием счетчика для объкта, чтобы узнать сколько свойств у объекта:

// let counter = 0;
// for (let key in options) {
//     if (typeof (options[key]) === 'object') {
//         for (let i in options[key]) {
//             console.log(`Свойство ${i} имеет значение ${options[key][i]}`);
//             counter++;
//          }
//     } else {
//         console.log(`Свойство ${key} имеет значение ${options[key]}`);
//         counter++;
//     }
// }
// console.log(counter); // получим 5 свойств, то есть всегосколько свойст, включая свойства вложенного объекта colors

// Если же мы хотим получить количесво свойств основного объекта без свойств вложенного объекта, тонужно использовать следующую конструкцию
// let counter = 0;
// for (let key in options) {
//     counter++;
// }
// console.log(counter); // получим 4

// Также у объекта есть такой метод, как Object.keys - ключи объекта.
// Этот метод берет наш объет и на его основании создает нам массив, в котором все элементы это ключи нашего объекта
//
// console.log(Object.keys(options)); // получим [ 'name', 'width', 'height', 'colors' ]
// console.log(Object.keys(options).length); //получим 4, у массива, как и сроки есть свойство lenght, чтобы узнать сколько эдементом там содержиться

// const anna = {
//     name: 'Anna',
//     age: 28,
//     isSheDoctor: true

// };

// console.log(Object.keys(anna).length); // получим 3

// const alex = {
//     name: 'Alex',
//     age: 34,
//     isHeProgrammer: true
// };

// console.log(Object.keys(alex).length); // получим 3

// Методы - это действия, которые могут выполнять наши дествия
/* const options = {
     name: 'test', // ключ: значение
     width: 1024,
     height: 1024,
     colors: {
         border: 'black',
         bg: 'red'
     },
     makeTest: function () {
         console.log('Test');
     }
 };
 options.makeTest(); - запуск метода 
 В данном случае выше мы создали метод makeTest 
 */


/* Деструктуризация объекта - это вытаскивание данных объекта в отдельные структуры и как-то в дальнейшем уже использовать

 
const options = {
    name: 'test', // ключ: значение
    width: 1024,
    height: 1024,
    colors: {
        border: 'black',
        bg: 'red'
    },
    makeTest: function () {
        console.log('Test');
    }
};
options.makeTest();*/
/*Деструктуризация : создаем переменную {пишем те свойства объекта, которые мы хотим вытащить } = объект, из которого , 
мы хотим вытащить эти переменные 

const { border, bg } = options.colors; - деструктуризация 

console.log(border); // получим black*/


/* МАССИВЫ И ПСЕВДОМАССИВЫ
Массивы - это структуры, которые содержат элементы по порядку  */

const arr = [1, 2, 3, 6, 8];

// // методы для работы с концом массива:

// arr.pop(); // удаляет последний элемент из нашего массива

// console.log(arr); // получим [ 1, 2, 3, 6 ]

// arr.push(10);
// console.log(arr); // получим [ 1, 2, 3, 6, 8, 10 ]

/* методы для работы с началом массива это, с ними есть некоторая сложность,
так вставляя или удаляя элемент в начале массива, нам нужно поменять индекс последующих элементов:*/

// arr.shift(); // удаляет первый элемент массива
// console.log(arr); // получим [ 2, 3, 6, 8 ]

// arr.unshift(10); // добавляет элемент в начало массива, в данном случае число 10
// console.log(arr); // получим [ 10, 1, 2, 3, 6, 8

// Чтобы перебрать массив, используется следующая конструкция:

// for (let i = 0; i < arr.length; i++) { // этот цикл будет отрабаьтывать до тех пор, пока не закончаться элементы массива
//      console.log(arr[i]); // для того чтобы обратиться к конкретному элементу массива , нам нужно назвать массив, поставить [], внутри которых нужно поставить идекс. В данном случае мы постави i, так i= 0, и потом с каждой иттерацией буде увеличиваться на 1
//  }


/*  или же можно использовать другую конструкцию:
 внутри этого цикла мы задаем какую-то переменную, которая будет отображать каждый отдельный элемент массива, дальше прише of  и название массива 
 конструкция for..of работает только с массивами или со строкой, псевдомассивом,  мэп и сэт (про них позжке), и также какими-то элементами со страницы
 Конструкцию for...of лучше использовать для перебора массива, когда мы также хотим использовать такие конструкции,
 как continua или break. Для остальных же случаев лучше использовать метод forEach(смотри ниже) */

//  for (let value of arr) {
//      console.log(value);
//  }

//  Свойство lenght у массива
//  console.log(arr.length); // получим 5 */

/* ОЧЕНЬ ВАЖНО! Как соотноситься между собой и порядковые номера внутри массива?
 Ответ: свойство lenght состоит из последнего индекса, который есть в массиве + 1.
Счет в массиве начинается с 0 

Массив содержит элементы строго по порядку, но иногда эти правила могут нарушиться, наример:*/

// arr[99] = 0; // так делать нельзя
// console.log(arr.length); //получим 100 (как-будто у нас 100 элементов)
// console.log(arr); // получим [ 1, 2, 3, 6, 8, <94 empty items>, 0 ] - 94 пустых ячейки

/* МЕТОДЫ МАССИВОВ
const arr = [1, 2, 3, 6, 8];

arr.forEach(function (item, i, arr ) {
    console.log(`${i}: ${item} внутри массива ${arr}`);
});  /* позволяет гибко перебрать все элемнты внутри массива, при этом его не модифицирует ,  в отличии от циклов для перебора массива, мы можем его чуть подробнее настроить. Этот метод принимает в себя еще коллбек функцию
эта коллбек функция будет выполняться каждый раз для каждого элемента массива
эта коллбек фу-ция может принимать 3 аргумента: 1-й -это тот элемент, который мы сейчас перебираем, например нашего массива, это будет 2, 3, или 6 и тд, назвать можно как угодно 
2-й аргумент - это номер по порядку
3-аргумент - это тот массив, который мы перебираем  
Также в этом методе continua и break не сработают  



arr.map() //модифицирует элементы и вернет нам новый массив, элементы,которого будут отличаться от старого

arr.filter() // отфильтровуе массив по тому критерию, который мы туда задаем, например оставить только четные числа, или оставить те элементы у которых тип данных строка
*/
/* МЕТОД split 

Внутри метода split мы должны указать, через какой разделитель будут эти товары в строке
Именно так на основании строк, мы може сформировать массив:

const str = prompt('', '');
const products = str.split(', ');
console.log(products); // получим ['ывыв', 'ыыа', 'апап', 'ауауа', 'цвввы'] , элементы массива это то что пользователь ввел в  prompt
*/
/* МЕТОД joint 

Есть и другой метод join, с помощью которого можно на основании массива сформировать строку
внутри метода join мы указываем тот разделитель, через который будут написаны элементы 

const str = prompt('', '');
const products = str.split(', '); // получили массив 
console.log(products.join('; ')); // получим  строчку, но уже элементы будут через ; например dddd; ffff; hhhh; www; kkk
*/
/*  МЕТОД sort - метод сортировки массива
Метод sort сортируют данные как строки, если в массиве строки, то он будет их сортировать как по алфавиту
Если в массиве числа, то он будет их сортировать как строки, но это можно исправить передав методу 
sort callbsck ф-цию, сказав как именно сортировать этот массив.
Метод sort содержит внутри себя алгорим быстрой сортировки 


const str = prompt('', '');
const products = str.split(', '); 
products.sort();
console.log(products.join('; ')); 

const arr = [1, 13, 26, 8, 10];
arr.sort(compareNum);
console.log(arr); // получим [1, 8, 10, 13, 26]

function compareNum(a, b) {
    return a - b;
}
*/

/* Псевдомассивы - это такой объкт структура, которог совпадает со структурой массива,
но у таких псевдомассивов не будет никаких методов, это просто структура, которая хранит данные по порядку 

Когда мы работаем с элементами на странице, то мы как раз и будем получать псевдомассивы */


/* ПЕРЕДАЧА ПО ССЫЛКЕ ИЛИ ПО ЗНАЧЕНИЮ, Spred оператор
let a = 5,
    b = a;

b = b + 5;
console.log(b); // получим 10
console.log(a); // получим 5

// когда мы работаем с примитивными типами данных (строки, числа, логические значени и тд), то они передаються по значеию 

const obj = {
    a: 5,
    b: 1
};
*/
// const copy = obj; // передает не саму структуру объекта, а ссылку, то есть в переменную copy кладеться ссылку на уже существующий объект

// copy.a = 10; // модифицирую нашу копию, мы модифицируем наш изначальный объект, потому что мы работаем не с копией, а именно со сслылкой на него

// console.log(copy); // получим { a: 10, b: 1 }
// console.log(obj); // получим { a: 10, b: 1 }
// когда же мы работаем с объектами, то передача данных идет уже по ссылке, а не позначению

// А как же создавать копии объектов, массивов и тд, для этого несколько способов:
// 1- способ:

// function copy(mainObj) { // эта функция при помощи цикла создаст новый объект перебирая старые свойства, которые были в нашем объекте
//     let objCopy = {};

//     let key;
//     for (key in mainObj) {
//         objCopy[key] = mainObj[key];
//     }

//     return objCopy;
// }

// const numbers = {
//     a: 2,
//     b: 5,
//     c: {
//         x: 7,
//         y: 4
//     }
// };

// const newNumbers = copy(numbers);

// newNumbers.a = 10;
// newNumbers.c.x = 10; // получим то, что х поменялось и в копии, и в начальном объекте

// console.log(newNumbers); //
// console.log(numbers); //
/* Важно понимать, что есть поверхностное копирование и глубокое копирование
Как только одно из свойств будет содержать вложеную структуру, например объект или массив, то это свойтво опять будет иметь ссылочный тип данных 
Пока мы только разбираем поверхностное копирование, а глубокое копирование разберем позже*/
// 2-й способ:
// Object.assign - такой метод объединяет два объекта
// const add = {
//     d: 17,
//     e: 20
// };

// console.log(Object.assign(numbers, add));
// первый аргумент - это объект в который мы хотим поместить, второй аргумент - объект, который мы помещаем
// получим { a: 2, b: 5, c: { x: 10, y: 4 }, d: 17, e: 20 }
// таким образом мы создали поверхностную копию объекта numbers + объект add

// const clone = Object.assign({}, add);
// clone.d = 20;
// console.log(clone); // получим { d: 20, e: 20 } - таким образом мы поверхностно скопировали объект add и поменяли в нем свойство d
// console.log(add); // получим { d: 17, e: 20 }


/* КОПИЯ МАССИВОВ
const oldArray = ['a', 'b', 'c'];

const newArray = oldArray.slice(); // slice - это метод , который позволяет скопировать старый массив , в него еще можно передать аргумент по количеству этих элементов

newArray[1] = 'Anna the best'; // меняем второй элемент 
console.log(newArray); // получим [ 'a', 'Anna the best', 'c' ] - таким образм мы создали поверх. копирование массива
console.log(oldArray); // получим [ 'a', 'b', 'c' ]

// 4- м способом создания поверхностной копии будет использование оператора разворота Spred -  оператор 
// это оператор разворачивает структуру и превращает ее в какой-то набор данных 

const video = ['youtube', 'vimeo', 'rutube'],
    blogs = ['wordpress', 'livejournal', 'blogger'],
    internet = [...video, ...blogs, 'vk', 'factbook']; // такой синтаксис позволит вытащить элементы из вышеперечисленных массивов и поместить их в переменную internet
console.log(internet);
//  Пполучим ['youtube','vimeo','rutube','wordpress','livejournal','blogger','vk','factbook']


function log(a, b, c) {
    console.log(a);
    console.log(b);
    console.log(c);
}

const num = [2, 5, 7];

log(...num); // теперь массив num разложиться на 3 отдельных элемента, получим 2 5 7

const array = ['a', 'b'];

const newAarray = [...array]; // теперь с помощью ... в этой переменной лежит копия переменной array


const q = {
    one: 1,
    two: 2
};

const nevObj = { ...q }; // таким образом мы с помощью ... поверхностно скопировали объект q

*/






/*Основы ООП, прототипно-ориентированное наследование
JS - объектно-ориентированый язык 
*/

// let str = 'some';
// let strObj = new String(str);

// console.log(typeof (str)); // string
// console.log(typeof (strObj)); // object

// console.dir([1, 2, 3]);


// const soldier = {
//     health: 400,
//     armor: 100,
//     sayHello: function () {
//         console.log('Hello');
//     }
// };

// const jonh = {
//     health: 100
// };


// jonh.__proto__ = soldier; // устаревшаяформа записи . установили прототип джона  - солдата


// Следующие конструкции на данный момент используються, чтобы назначить прототип и тд:

// Object.setPrototypeOf(jonh, soldier); // эта запись идентична этой записи jonh.__proto__ = soldier;
// первый аргумент - это объект, которому я хочу назначить прототип
// второй аргумент - это тот объект прототип, которого мы установливаем

// console.log(jonh); //{ health: 100 }
// console.log(jonh.armor); // 100 - такая взаимосвязь очень помогает в проектах
// jonh.sayHello(); // Hello


// Чтобы сразу создавать прототип, то мы используем следующую конструкцию:

// const jonh = Object.create(soldier); // создаем новый объект джон, который будет прототипно наследоваться от солдата

// jonh.sayHello(); // Hello




/*Отлавливаем ошибки в коде при поимощи консоли разработчика 
Breakpoints - это такая метка, которая позволяет останавливать код в определенном участке
*/



/* Динамическая типизация в JS
- это возможность одного типа данных превращаться в другой, то есть число может стать строй,
стока - числом, а объект- булиновым значением 
Статическая типизация - это когда например число всегда остаеться числом 
*/

// To String
//1) Самый старый способ -  команда String

// console.log(typeof (String(null))); // string // потому что наша команда превратила тип данных null в string
// console.log(typeof (String(4))); // string

// //2) Конкатинация - когда мы что-то складываем со строкой

// console.log(typeof (5 + '')); // string

// console.log(typeof (null + '')); // string

// const num = 5;

// console.log('https://vk.com/catalog/' + num); //https://vk.com/catalog/5

// const fontSize = 26 + 'px';




// // To Number
// //1)
// console.log(typeof (Number('4'))); // number

// //2) Унарный +
// console.log(typeof (+'5')); // number

// let answ = +prompt('Hello', ''); // от пользователя мы всегда получаем строки, и для того чтобы преобразовать данные перед prompt ставим +

// // 3)
// console.log(typeof (parseInt('15px', 10))); // number



// // To boolean

// //Данные, которые всегда будут возвращать false:
// // 0, ''(пустая строка без пробела), null, undefined, NaN

// // Все остальное будет возвращать true

// //1)
// let switcher = null;

// if (switcher) {
//     console.log('Working'); // работать не будет, потому что switcher => null => false
// }

// switcher = 1;
// if (switcher) {
//     console.log('Working'); // working, потому что switcher =>1 => true
// }

// //2)
// console.log(typeof (Boolean('4'))); // boolean
// console.log(Boolean('4')); // true

// //3)
// console.log(typeof (!! '55555')); // boolean // используеться очень редко




/* ЗАДАЧИ С СОБЕСЕДОВАНИЙ НА ПОНМАНИЕ ОСНОВ 

1. Какое будет выведено значение: let x = 5; alert( x++ ); ?
2. Чему равно такое выражение: [ ] + false - null + true ?
3. Что выведет этот код: let y = 1; let x = y = 2; alert(x); ?
4. Чему равна сумма [ ] + 1 + 2?
5. Что выведет этот код: alert( '1'[0] )?
6. Чему равно 2 && 1 &&  0 && undefined ?
7. Есть ли разница между выражениями? !!( a && b ) и (a && b)?
8. Что выведет этот код: alert( null || 2 && 3 || 4 ); ?
9. a = [1, 2, 3]; b = [1, 2, 3]; Правда ли что a == b ?
10.  Что выведет этот код: alert( +'Infinity'); ?
11. Верно ли сравнение: 'Ёжик' > 'яблоко&quot'?
12. Чему равно 0 || '' || 2 || undefined || true || falsе ?

*/
//1)
// let b = 5;
// console.log(x++); // 5, префиксная форма - выводит новое значение, постфиксная форма - выводит старое значение

// //2)
// console.log([] + false - null + true);  // NaN - потому что математические опеации выполняються не с числами
// //[] - когда мы добавляем пустой массив, то он ведет себя, как пустая строка
// console.log(typeof ([] + false)); // string// [] + false => '' + false => если мы добавляем строку с каким либо другим типом данныъ, то мы получаем строку



//3)
// let y = 1;
// let x = y = 2;
// console.log(x); // 2 // последовательное присваивание


//4)
// console.log([] + 1 + 2); //12 // [] - пустой массив превращаеться в пустую строку ''
// console.log(typeof ([] + 1 + 2)); // string


//5)
// console.log('1'[0]); // 1
// // [0] - индекс, с помощью которого мы обращаемся к какому-т о элементу строки '1', но так как элементов всего 1, то и выведет 1
// console.log('Anna'[0]); // A
// console.log('Anna'[1]); // n



//6)
// console.log(2 && 1 && null && 0 && undefined); // null
// оператор && - выводит первое ложное значение, если таких нет, то выводит последнее



//7)
// console.log(!!(1 && 2)); // true
// console.log(1 && 2); //2
// !! - возвращает буллиновое значение
//двойное НЕ !! используют для преобразования значений к логическому типу
// console.log( !!"non-empty string" ); // true
// console.log( !!null ); // false
/*То есть первое НЕ преобразует значение в логическое значение и возвращает обратное, 
а второе НЕ снова инвертирует его.
В конце мы имеем простое преобразование значения в логическое.*/
// console.log(!!1); // true // то есть  !1 => false => !false=> true


//8)
// console.log(null || 2 && 3 || 4);
// // && оператор имеет больше приоритет, чем оператор || :
// console.log(2 && 3); // && выводит первое ложное значение, если его нет выводит последнее

// console.log(null || 3 || 4); // 3, потому что оператор || выводит первое истенное значение


//9) правда что a == b
// const a = [1, 2, 3];

// const b = [1, 2, 3];

// console.log(a == b); // false

//10)
// console.log(+'Infinity'); //Infinity, потому что унарный + преобразует строки в числа
// console.log(typeof (+'Infinitt')); // number

//11)

// console.log('Ёжик' > 'яблоко'); // false, потому что:
/*Например, в JavaScript имеет значение регистр символов. Заглавная буква "A" не равна строчной "a". Какая же из них больше? Строчная "a". Почему? Потому что строчные буквы имеют 
больший код во внутренней таблице кодирования, которую использует JavaScript (Unicode). */

//12)
// console.log(0 || '' || 2 || undefined || true || falsе); //2
// оператор || выводит первое стенное значение






// ПОЛУЧЕНИЕ ЭЛЕМЕНТОВ СО СТРАНИЦЫ
// смотри в папке js1 => папка elements





// СОБЫТИЯ И ИХ ОБРАБОТЧИКИ - СМОТРИ ПАПКУ PREVIEW
// События = это сигнал от браузера о том у что у нас что-то произошло:
// клик
// двойной клик
// наведени мыши и др.
// Все чем занимаеться пользователь на странице - это события, и мы их можем отлавливать
// Чтобы использовать события, мы должны назначить обработчик события -  это фу-ция, которая срабвтывает, как только событие произошло
// Если пользователь нажимает мышью на какой-то гамбургер-меню, то срабатывает функция, которая открывает это самое меню
//Если пользователь нажимает кнопку "отправить данные", то эти данные оправляються и тд
//сначала событие => потом обработка события (действие - функция)

// ТРИ СПОСОБА НАЗНАЧИТЬ ОБРАБОТЧИКА СОБЫТИЯ:
// СМОТРИ ПАПКУ PREVIEW











































